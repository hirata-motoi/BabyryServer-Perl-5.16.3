.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Session2 3"
.TH HTTP::Session2 3 "2014-04-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Session2 \- HTTP session management
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package MyApp;
\&    use HTTP::Session2;
\&
\&    sub session {
\&        my $self = shift;
\&        if (!exists $self\->{session}) {
\&            $self\->{session} = HTTP::Session2::ClientStore\->new(env => $env, secret => \*(Aqvery long secret string\*(Aq);
\&        }
\&        $self\->{session};
\&    }
\&
\&    _\|_PACKAGE_\|_\->add_trigger(
\&        AFTER_DISPATCH => sub {
\&            my ($c, $res) = @_;
\&            if ($c\->{session}) {
\&                $c\->{session}\->finalize_plack_response($res);
\&            }
\&        },
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
HTTP::Session2 is yet another \s-1HTTP\s0 session data management library.
.SH "RELEASE STATE"
.IX Header "RELEASE STATE"
Alpha. Any \s-1API\s0 will change without notice.
.SH "MOTIVATION"
.IX Header "MOTIVATION"
We need a thrifty session management library.
.SH "What's different from HTTP::Session 1?"
.IX Header "What's different from HTTP::Session 1?"
.SS "Generate \s-1XSRF\s0 protection token by session management library"
.IX Subsection "Generate XSRF protection token by session management library"
Most of web application needs \s-1XSRF\s0 protection library.
.PP
tokuhirom guess \s-1XSRF\s0 token is closely related with session management.
.SS "Dropped StickyQuery support"
.IX Subsection "Dropped StickyQuery support"
In Japan, old DoCoMo's phone does not support cookie.
Then, we need to support query parameter based session management.
.PP
But today, Japanese people are using smart phone :)
We don't have to support legacy phones on new project.
.SH "Automatic XSRF token sending."
.IX Header "Automatic XSRF token sending."
This is an example code for filling \s-1XSRF\s0 token.
This code requires jQuery.
.PP
.Vb 2
\&    $(function () {
\&        "use strict";
\&
\&        var xsrf_token = getXSRFToken();
\&        $("form").each(function () {
\&            var form = $(this);
\&            var method = form.attr(\*(Aqmethod\*(Aq);
\&            if (method === \*(Aqget\*(Aq || method === \*(AqGET\*(Aq) {
\&                return;
\&            }
\&
\&            var input = $(document.createElement(\*(Aqinput\*(Aq));
\&            input.attr(\*(Aqtype\*(Aq,  \*(Aqhidden\*(Aq);
\&            input.attr(\*(Aqname\*(Aq,  \*(AqXSRF\-TOKEN\*(Aq);
\&            input.attr(\*(Aqvalue\*(Aq,  xsrf_token);
\&            form.prepend(input);
\&        });
\&
\&        function getXSRFToken() {
\&            var cookies = document.cookie.split(/\es*;\es*/);
\&            for (var i=0,l=cookies.length; i<l; i++) {
\&                var matched = cookies[i].match(/^XSRF\-TOKEN=(.*)$/);
\&                if (matched) {
\&                    return matched[1];
\&                }
\&            }
\&            return undefined;
\&        }
\&    });
.Ve
.SH "Validate XSRF token in your application"
.IX Header "Validate XSRF token in your application"
You need to call \s-1XSRF\s0 validator.
.PP
.Vb 4
\&    _\|_PACKAGE_\|_\->add_trigger(
\&        BEFORE_DISPATCH => sub {
\&            my $c = shift;
\&            my $req = $c\->req;
\&
\&            if ($req\->method ne \*(AqGET\*(Aq && $req\->method ne \*(AqHEAD\*(Aq) {
\&                my $xsrf_token = $req\->header(\*(AqX\-XSRF\-TOKEN\*(Aq) || $req\->param(\*(Aqxsrf\-token\*(Aq);
\&                unless ($session\->validate_xsrf_token($xsrf_token)) {
\&                    return [
\&                        403,
\&                        [],
\&                        [\*(AqXSRF detected\*(Aq],
\&                    ];
\&                }
\&            }
\&            return;
\&        }
\&    );
.Ve
.SH "pros/cons for ServerStore/ClientStore"
.IX Header "pros/cons for ServerStore/ClientStore"
.SS "ServerStore"
.IX Subsection "ServerStore"
\fIpros\fR
.IX Subsection "pros"
.IP "It was used well." 4
.IX Item "It was used well."
.PD 0
.IP "User can't see anything." 4
.IX Item "User can't see anything."
.IP "You can store large data in session." 4
.IX Item "You can store large data in session."
.PD
.PP
\fIcons\fR
.IX Subsection "cons"
.IP "Setup is hard." 4
.IX Item "Setup is hard."
You need to setup some configuration for your application.
.SS "ClientStore"
.IX Subsection "ClientStore"
\fIpros\fR
.IX Subsection "pros"
.IP "You don't need to store anything on your server" 4
.IX Item "You don't need to store anything on your server"
It makes easy to setup your server environment.
.IP "Less server side disk" 4
.IX Item "Less server side disk"
It helps your wallet.
.PP
\fIcons\fR
.IX Subsection "cons"
.IP "Security" 4
.IX Item "Security"
I hope this module is secure. Because the data was signed by \s-1HMAC\s0. But security thing is hard.
.IP "Session data is readable by users" 4
.IX Item "Session data is readable by users"
You can't store the any secret data to the session. Because this library signed to the data, but not encrypted.
.IP "Bandwidth" 4
.IX Item "Bandwidth"
If you store the large data to the session, your session data is send to the server per every request.
It may hits band-width issue. If you are writing high traffic web site, you should use server side store.
.IP "Capacity" 4
.IX Item "Capacity"
Cookies are usually limited to 4096 bytes. You can't store large data to the session.
You should care the cookie size, or checking cookie size by the Plack::Middleware layer.
.Sp
Ref. \s-1RFC2965\s0 <http://tools.ietf.org/html/rfc2965>
.SH "FAQ"
.IX Header "FAQ"
.ie n .IP "How can I implement ""Keep me signed in"" checkbox?" 4
.el .IP "How can I implement ``Keep me signed in'' checkbox?" 4
.IX Item "How can I implement Keep me signed in checkbox?"
You can implement it like following:
.Sp
.Vb 9
\&    sub dispatch_login {
\&        my $c = shift;
\&        if ($c\->request\->parameters\->{\*(Aqkeep_me_signed_in\*(Aq}) {
\&            $c\->session\->session_cookie\->{expires} = \*(Aq+1M\*(Aq;
\&        }
\&        $c\->session\->regenerate_id();
\&        my $user = User\->login($c\->request\->parameters);
\&        $c\->session\->set(\*(Aquser_id\*(Aq => $user\->id);
\&    }
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) tokuhirom.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
tokuhirom <tokuhirom@gmail.com>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
magai
