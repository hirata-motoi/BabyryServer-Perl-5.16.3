.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Teng 3"
.TH Teng 3 "2014-04-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Teng \- very simple DBI wrapper/ORMapper
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    my $db = MyDB\->new({ connect_info => [ \*(Aqdbi:SQLite:\*(Aq ] });
\&    my $row = $db\->insert( \*(Aqtable\*(Aq => {
\&        col1 => $value
\&    } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Teng is very simple \s-1DBI\s0 wrapper and simple O/R Mapper.
It aims to be lightweight, with minimal dependencies so it's easier to install.
.SH "BASIC USAGE"
.IX Header "BASIC USAGE"
create your db model base class.
.PP
.Vb 3
\&    package Your::Model;
\&    use parent \*(AqTeng\*(Aq;
\&    1;
.Ve
.PP
create your db schema class.
See Teng::Schema for docs on defining schema class.
.PP
.Vb 8
\&    package Your::Model::Schema;
\&    use Teng::Schema::Declare;
\&    table {
\&        name \*(Aquser\*(Aq;
\&        pk \*(Aqid\*(Aq;
\&        columns qw( foo bar baz );
\&    };
\&    1;
.Ve
.PP
in your script.
.PP
.Vb 1
\&    use Your::Model;
\&    
\&    my $teng = Your::Model\->new(\e%args);
\&    # insert new record.
\&    my $row = $teng\->insert(\*(Aquser\*(Aq,
\&        {
\&            id   => 1,
\&        }
\&    );
\&    $row\->update({name => \*(Aqnekokak\*(Aq}); # same do { $row\->name(\*(Aqnekokak\*(Aq); $row\->update; }
\&
\&    $row = $teng\->single_by_sql(q{SELECT id, name FROM user WHERE id = ?}, [ 1 ]);
\&    $row\->delete();
.Ve
.SH "ARCHITECTURE"
.IX Header "ARCHITECTURE"
Teng classes are comprised of three distinct components:
.SS "\s-1MODEL\s0"
.IX Subsection "MODEL"
The \f(CW\*(C`model\*(C'\fR is where you say
.PP
.Vb 2
\&    package MyApp::Model;
\&    use parent \*(AqTeng\*(Aq;
.Ve
.PP
This is the entry point to using Teng. You connect, insert, update, delete, select stuff using this object.
.SS "\s-1SCHEMA\s0"
.IX Subsection "SCHEMA"
The \f(CW\*(C`schema\*(C'\fR is a simple class that describes your table definitions. Note that this is different from DBIx::Class terms.
\&\s-1DBIC\s0's schema is equivalent to Teng's model + schema, where the actual schema information is scattered across the result classes.
.PP
In Teng, you simply use Teng::Schema's domain specific language to define a set of tables
.PP
.Vb 2
\&    package MyApp::Model::Schema;
\&    use Teng::Schema::Declare;
\&
\&    table {
\&        name $table_name;
\&        pk $primary_key_column;
\&        columns qw(
\&            column1
\&            column2
\&            column3
\&        );
\&    }
\&
\&    ... and other tables ...
.Ve
.SS "\s-1ROW\s0"
.IX Subsection "ROW"
Unlike DBIx::Class, you don't need to have a set of classes that represent a row type (i.e. \*(L"result\*(R" classes in \s-1DBIC\s0 terms).
In Teng, the row objects are blessed into anonymous classes that inherit from Teng::Row,
so you don't have to create these classes if you just want to use some simple queries.
.PP
If you want to define methods to be performed by your row objects, simply create a row class like so:
.PP
.Vb 2
\&    package MyApp::Model::Row::Camelizedtable_name;
\&    use parent qw(Teng::Row);
.Ve
.PP
Note that your table name will be camelized.
.SH "METHODS"
.IX Header "METHODS"
Teng provides a number of methods to all your classes,
.ie n .IP "$teng = Teng\->new(\e%args)" 4
.el .IP "\f(CW$teng\fR = Teng\->new(\e%args)" 4
.IX Item "$teng = Teng->new(%args)"
Creates a new Teng instance.
.Sp
.Vb 4
\&    # connect new database connection.
\&    my $db = Your::Model\->new(
\&        connect_info => [ $dsn, $username, $password, \e%connect_options ]
\&    );
.Ve
.Sp
Arguments can be:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`connect_info\*(C'\fR
.Sp
Specifies the information required to connect to the database.
The argument should be a reference to a array in the form:
.Sp
.Vb 1
\&    [ $dsn, $user, $password, \e%options ]
.Ve
.Sp
You must pass \f(CW\*(C`connect_info\*(C'\fR or \f(CW\*(C`dbh\*(C'\fR to the constructor.
.IP "\(bu" 4
\&\f(CW\*(C`dbh\*(C'\fR
.Sp
Specifies the database handle to use.
.IP "\(bu" 4
\&\f(CW\*(C`no_ping\*(C'\fR
.Sp
By default, ping before each executing query.
If it affect performance then you can set to true for ping stopping.
.IP "\(bu" 4
\&\f(CW\*(C`fields_case\*(C'\fR
.Sp
specific \s-1DBI\s0.pm's FetchHashKeyName.
.IP "\(bu" 4
\&\f(CW\*(C`schema\*(C'\fR
.Sp
Specifies the Teng::Schema instance to use.
If not specified, the value specified in \f(CW\*(C`schema_class\*(C'\fR is loaded and 
instantiated for you.
.IP "\(bu" 4
\&\f(CW\*(C`schema_class\*(C'\fR
.Sp
Specifies the schema class to use.
By default {\s-1YOUR_MODEL_CLASS\s0}::Schema is used.
.IP "\(bu" 4
\&\f(CW\*(C`txn_manager_class\*(C'\fR
.Sp
Specifies the transaction manager class.
By default DBIx::TransactionManager is used.
.IP "\(bu" 4
\&\f(CW\*(C`suppress_row_objects\*(C'\fR
.Sp
Specifies the row object creation mode. By default this value is \f(CW\*(C`false\*(C'\fR.
If you specifies this to a \f(CW\*(C`true\*(C'\fR value, no row object will be created when
a \f(CW\*(C`SELECT\*(C'\fR statement is issued..
.IP "\(bu" 4
\&\f(CW\*(C`sql_builder\*(C'\fR
.Sp
Speficies the \s-1SQL\s0 builder object. By default SQL::Maker is used, and as such,
if you provide your own \s-1SQL\s0 builder the interface needs to be compatible
with SQL::Maker.
.RE
.RS 4
.RE
.ie n .IP """$row = $teng\->insert($table_name, \e%row_data)""" 4
.el .IP "\f(CW$row = $teng\->insert($table_name, \e%row_data)\fR" 4
.IX Item "$row = $teng->insert($table_name, %row_data)"
Inserts a new record. Returns the inserted row object.
.Sp
.Vb 4
\&    my $row = $teng\->insert(\*(Aquser\*(Aq,{
\&        id   => 1,
\&        name => \*(Aqnekokak\*(Aq,
\&    });
.Ve
.Sp
If a primary key is available, it will be fetched after the insert \*(-- so
an \s-1INSERT\s0 followed by \s-1SELECT\s0 is performed. If you do not want this, use
\&\f(CW\*(C`fast_insert\*(C'\fR.
.ie n .IP """$last_insert_id = $teng\->fast_insert($table_name, \e%row_data);""" 4
.el .IP "\f(CW$last_insert_id = $teng\->fast_insert($table_name, \e%row_data);\fR" 4
.IX Item "$last_insert_id = $teng->fast_insert($table_name, %row_data);"
insert new record and get last_insert_id.
.Sp
no creation row object.
.ie n .IP """$teng\->bulk_insert($table_name, \e@rows_data)""" 4
.el .IP "\f(CW$teng\->bulk_insert($table_name, \e@rows_data)\fR" 4
.IX Item "$teng->bulk_insert($table_name, @rows_data)"
Accepts either an arrayref of hashrefs.
each hashref should be a structure suitable
for submitting to a Your::Model\->insert(...) method.
The second argument is an arrayref of hashrefs. All of the keys in these hashrefs must be exactly the same.
.Sp
insert many record by bulk.
.Sp
example:
.Sp
.Vb 10
\&    Your::Model\->bulk_insert(\*(Aquser\*(Aq,[
\&        {
\&            id   => 1,
\&            name => \*(Aqnekokak\*(Aq,
\&        },
\&        {
\&            id   => 2,
\&            name => \*(Aqyappo\*(Aq,
\&        },
\&        {
\&            id   => 3,
\&            name => \*(Aqwalf443\*(Aq,
\&        },
\&    ]);
.Ve
.ie n .IP """$update_row_count = $teng\->update($table_name, \e%update_row_data, [\e%update_condition])""" 4
.el .IP "\f(CW$update_row_count = $teng\->update($table_name, \e%update_row_data, [\e%update_condition])\fR" 4
.IX Item "$update_row_count = $teng->update($table_name, %update_row_data, [%update_condition])"
Calls \s-1UPDATE\s0 on \f(CW$table_name\fR, with values specified in \f(CW%update_ro_data\fR, and returns the number of rows updated. You may optionally specify \f(CW%update_condition\fR to create a conditional update query.
.Sp
.Vb 9
\&    my $update_row_count = $teng\->update(\*(Aquser\*(Aq,
\&        {
\&            name => \*(Aqnomaneko\*(Aq,
\&        },
\&        {
\&            id => 1
\&        }
\&    );
\&    # Executes UPDATE user SET name = \*(Aqnomaneko\*(Aq WHERE id = 1
.Ve
.Sp
You can also call update on a row object:
.Sp
.Vb 2
\&    my $row = $teng\->single(\*(Aquser\*(Aq,{id => 1});
\&    $row\->update({name => \*(Aqnomaneko\*(Aq});
.Ve
.Sp
You can use the set_column method:
.Sp
.Vb 3
\&    my $row = $teng\->single(\*(Aquser\*(Aq, {id => 1});
\&    $row\->set_column( name => \*(Aqyappo\*(Aq );
\&    $row\->update;
.Ve
.Sp
you can column update by using column method:
.Sp
.Vb 3
\&    my $row = $teng\->single(\*(Aquser\*(Aq, {id => 1});
\&    $row\->name(\*(Aqyappo\*(Aq);
\&    $row\->update;
.Ve
.ie n .IP """$updated_row_count = $teng\->do_update($table_name, \e%set, \e%where)""" 4
.el .IP "\f(CW$updated_row_count = $teng\->do_update($table_name, \e%set, \e%where)\fR" 4
.IX Item "$updated_row_count = $teng->do_update($table_name, %set, %where)"
This is low level \s-1API\s0 for \s-1UPDATE\s0. Normally, you should use update method instead of this.
.Sp
This method does not deflate \e%args.
.ie n .IP """$delete_row_count = $teng\->delete($table, \e%delete_condition)""" 4
.el .IP "\f(CW$delete_row_count = $teng\->delete($table, \e%delete_condition)\fR" 4
.IX Item "$delete_row_count = $teng->delete($table, %delete_condition)"
Deletes the specified record(s) from \f(CW$table\fR and returns the number of rows deleted. You may optionally specify \f(CW%delete_condition\fR to create a conditional delete query.
.Sp
.Vb 4
\&    my $rows_deleted = $teng\->delete( \*(Aquser\*(Aq, {
\&        id => 1
\&    } );
\&    # Executes DELETE FROM user WHERE id = 1
.Ve
.Sp
You can also call delete on a row object:
.Sp
.Vb 2
\&    my $row = $teng\->single(\*(Aquser\*(Aq, {id => 1});
\&    $row\->delete
.Ve
.ie n .IP """$itr = $teng\->search($table_name, [\e%search_condition, [\e%search_attr]])""" 4
.el .IP "\f(CW$itr = $teng\->search($table_name, [\e%search_condition, [\e%search_attr]])\fR" 4
.IX Item "$itr = $teng->search($table_name, [%search_condition, [%search_attr]])"
simple search method.
search method get Teng::Iterator's instance object.
.Sp
see Teng::Iterator
.Sp
get iterator:
.Sp
.Vb 1
\&    my $itr = $teng\->search(\*(Aquser\*(Aq,{id => 1},{order_by => \*(Aqid\*(Aq});
.Ve
.Sp
get rows:
.Sp
.Vb 1
\&    my @rows = $teng\->search(\*(Aquser\*(Aq,{id => 1},{order_by => \*(Aqid\*(Aq});
.Ve
.ie n .IP """$row = $teng\->single($table_name, \e%search_condition)""" 4
.el .IP "\f(CW$row = $teng\->single($table_name, \e%search_condition)\fR" 4
.IX Item "$row = $teng->single($table_name, %search_condition)"
get one record.
give back one case of the beginning when it is acquired plural records by single method.
.Sp
.Vb 1
\&    my $row = $teng\->single(\*(Aquser\*(Aq,{id =>1});
.Ve
.ie n .IP """$row = $teng\->new_row_from_hash($table_name, \e%row_data, [$sql])""" 4
.el .IP "\f(CW$row = $teng\->new_row_from_hash($table_name, \e%row_data, [$sql])\fR" 4
.IX Item "$row = $teng->new_row_from_hash($table_name, %row_data, [$sql])"
create row object from data. (not fetch from db.)
It's useful in such as testing.
.Sp
.Vb 2
\&    my $row = $teng\->new_row_from_hash(\*(Aquser\*(Aq, { id => 1, foo => "bar" });
\&    say $row\->foo; # say bar
.Ve
.ie n .IP """$itr = $teng\->search_named($sql, [\e%bind_values, [$table_name]])""" 4
.el .IP "\f(CW$itr = $teng\->search_named($sql, [\e%bind_values, [$table_name]])\fR" 4
.IX Item "$itr = $teng->search_named($sql, [%bind_values, [$table_name]])"
execute named query
.Sp
.Vb 1
\&    my $itr = $teng\->search_named(q{SELECT * FROM user WHERE id = :id}, {id => 1});
.Ve
.Sp
If you give ArrayRef to value, that is expanded to \*(L"(?,?,?,?)\*(R" in \s-1SQL\s0.
It's useful in case use \s-1IN\s0 statement.
.Sp
.Vb 3
\&    # SELECT * FROM user WHERE id IN (?,?,?);
\&    # bind [1,2,3]
\&    my $itr = $teng\->search_named(q{SELECT * FROM user WHERE id IN :ids}, {ids => [1, 2, 3]});
.Ve
.Sp
If you give table_name. It is assumed the hint that makes Teng::Row's Object.
.ie n .IP """$itr = $teng\->search_by_sql($sql, [\e@bind_values, [$table_name]])""" 4
.el .IP "\f(CW$itr = $teng\->search_by_sql($sql, [\e@bind_values, [$table_name]])\fR" 4
.IX Item "$itr = $teng->search_by_sql($sql, [@bind_values, [$table_name]])"
execute your \s-1SQL\s0
.Sp
.Vb 8
\&    my $itr = $teng\->search_by_sql(q{
\&        SELECT
\&            id, name
\&        FROM
\&            user
\&        WHERE
\&            id = ?
\&    },[ 1 ]);
.Ve
.Sp
If \f(CW$table\fR is specified, it set table information to result iterator.
So, you can use table row class to search_by_sql result.
.ie n .IP """$row = $teng\->single_by_sql($sql, [\e@bind_values, [$table_name]])""" 4
.el .IP "\f(CW$row = $teng\->single_by_sql($sql, [\e@bind_values, [$table_name]])\fR" 4
.IX Item "$row = $teng->single_by_sql($sql, [@bind_values, [$table_name]])"
get one record from your \s-1SQL\s0.
.Sp
.Vb 1
\&    my $row = $teng\->single_by_sql(q{SELECT id,name FROM user WHERE id = ? LIMIT 1}, [1], \*(Aquser\*(Aq);
.Ve
.Sp
This is a shortcut for
.Sp
.Vb 1
\&    my $row = $teng\->search_by_sql(q{SELECT id,name FROM user WHERE id = ? LIMIT 1}, [1], \*(Aquser\*(Aq)\->next;
.Ve
.Sp
But optimized implementation.
.ie n .IP """$row = $teng\->single_named($sql, [\e%bind_values, [$table_name]])""" 4
.el .IP "\f(CW$row = $teng\->single_named($sql, [\e%bind_values, [$table_name]])\fR" 4
.IX Item "$row = $teng->single_named($sql, [%bind_values, [$table_name]])"
get one record from execute named query
.Sp
.Vb 1
\&    my $row = $teng\->single_named(q{SELECT id,name FROM user WHERE id = :id LIMIT 1}, {id => 1}, \*(Aquser\*(Aq);
.Ve
.Sp
This is a shortcut for
.Sp
.Vb 1
\&    my $row = $teng\->search_named(q{SELECT id,name FROM user WHERE id = :id LIMIT 1}, {id => 1}, \*(Aquser\*(Aq)\->next;
.Ve
.Sp
But optimized implementation.
.ie n .IP """$sth = $teng\->execute($sql, [\e@bind_values])""" 4
.el .IP "\f(CW$sth = $teng\->execute($sql, [\e@bind_values])\fR" 4
.IX Item "$sth = $teng->execute($sql, [@bind_values])"
execute query and get statement handler.
and will be inserted caller's file and line as a comment in the \s-1SQL\s0 if \f(CW$ENV\fR{\s-1TENG_SQL_COMMENT\s0} or sql_comment is true value.
.ie n .IP """$teng\->txn_scope""" 4
.el .IP "\f(CW$teng\->txn_scope\fR" 4
.IX Item "$teng->txn_scope"
Creates a new transaction scope guard object.
.Sp
.Vb 2
\&    do {
\&        my $txn = $teng\->txn_scope;
\&
\&        $row\->update({foo => \*(Aqbar\*(Aq});
\&
\&        $txn\->commit;
\&    }
.Ve
.Sp
If an exception occurs, or the guard object otherwise leaves the scope
before \f(CW\*(C`$txn\->commit\*(C'\fR is called, the transaction will be rolled
back by an explicit \*(L"txn_rollback\*(R" call. In essence this is akin to
using a \*(L"txn_begin\*(R"/\*(L"txn_commit\*(R" pair, without having to worry
about calling \*(L"txn_rollback\*(R" at the right places. Note that since there
is no defined code closure, there will be no retries and other magic upon
database disconnection.
.ie n .IP """$txn_manager = $teng\->txn_manager""" 4
.el .IP "\f(CW$txn_manager = $teng\->txn_manager\fR" 4
.IX Item "$txn_manager = $teng->txn_manager"
Create the transaction manager instance with specified \f(CW\*(C`txn_manager_class\*(C'\fR.
.ie n .IP """$teng\->txn_begin""" 4
.el .IP "\f(CW$teng\->txn_begin\fR" 4
.IX Item "$teng->txn_begin"
start new transaction.
.ie n .IP """$teng\->txn_commit""" 4
.el .IP "\f(CW$teng\->txn_commit\fR" 4
.IX Item "$teng->txn_commit"
commit transaction.
.ie n .IP """$teng\->txn_rollback""" 4
.el .IP "\f(CW$teng\->txn_rollback\fR" 4
.IX Item "$teng->txn_rollback"
rollback transaction.
.ie n .IP """$teng\->txn_end""" 4
.el .IP "\f(CW$teng\->txn_end\fR" 4
.IX Item "$teng->txn_end"
finish transaction.
.ie n .IP """$teng\->do($sql, [\e%option, @bind_values])""" 4
.el .IP "\f(CW$teng\->do($sql, [\e%option, @bind_values])\fR" 4
.IX Item "$teng->do($sql, [%option, @bind_values])"
Execute the query specified by \f(CW$sql\fR, using \f(CW%option\fR and \f(CW@bind_values\fR as necessary. This pretty much a wrapper around <http://search.cpan.org/dist/DBI/DBI.pm#do>
.ie n .IP """$teng\->dbh""" 4
.el .IP "\f(CW$teng\->dbh\fR" 4
.IX Item "$teng->dbh"
get database handle.
.ie n .IP """$teng\->connect(\e@connect_info)""" 4
.el .IP "\f(CW$teng\->connect(\e@connect_info)\fR" 4
.IX Item "$teng->connect(@connect_info)"
connect database handle.
.Sp
connect_info is [$dsn, \f(CW$user\fR, \f(CW$password\fR, \f(CW$options\fR].
.Sp
If you give \e@connect_info, create new database connection.
.ie n .IP """$teng\->disconnect()""" 4
.el .IP "\f(CW$teng\->disconnect()\fR" 4
.IX Item "$teng->disconnect()"
Disconnects from the currently connected database.
.ie n .IP """$teng\->suppress_row_objects($flag)""" 4
.el .IP "\f(CW$teng\->suppress_row_objects($flag)\fR" 4
.IX Item "$teng->suppress_row_objects($flag)"
set row object creation mode.
.ie n .IP """$teng\->load_plugin();""" 4
.el .IP "\f(CW$teng\->load_plugin();\fR" 4
.IX Item "$teng->load_plugin();"
.Vb 1
\& $teng\->load_plugin($plugin_class, $options);
.Ve
.Sp
This imports plugin class's methods to \f(CW$teng\fR class
and it calls \f(CW$plugin_class\fR's init method if it has.
.Sp
.Vb 1
\& $plugin_class\->init($teng, $options);
.Ve
.Sp
If you want to change imported method name, use \f(CW\*(C`alias\*(C'\fR option.
for example:
.Sp
.Vb 1
\& YourDB\->load_plugin(\*(AqBulkInsert\*(Aq, { alias => { bulk_insert => \*(Aqisnert_bulk\*(Aq } });
.Ve
.Sp
BulkInsert's \*(L"bulk_insert\*(R" method is imported as \*(L"insert_bulk\*(R".
.ie n .IP """$teng\->handle_error""" 4
.el .IP "\f(CW$teng\->handle_error\fR" 4
.IX Item "$teng->handle_error"
handling error method.
.IP "How do you use display the profiling result?" 4
.IX Item "How do you use display the profiling result?"
use Devel::KYTProf.
.SH "TRIGGERS"
.IX Header "TRIGGERS"
Teng does not support triggers (\s-1NOTE:\s0 do not confuse it with \s-1SQL\s0 triggers \- we're talking about Perl level triggers). If you really want to hook into the various methods, use something like Moose, Mouse, and Class::Method::Modifiers.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "Fork"
.IX Subsection "Fork"
This module was forked from DBIx::Skinny, around version 0.0732.
many incompatible changes have been made.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.SH "AUTHORS"
.IX Header "AUTHORS"
Atsushi Kobayashi  \f(CW\*(C`<nekokak _\|_at_\|_ gmail.com>\*(C'\fR
.PP
Tokuhiro Matsuno <tokuhirom@gmail.com>
.PP
Daisuke Maki \f(CW\*(C`<daisuke@endeworks.jp>\*(C'\fR
.SH "SUPPORT"
.IX Header "SUPPORT"
.Vb 1
\&  irc: #dbix\-skinny@irc.perl.org
\&
\&  ML: http://groups.google.com/group/dbix\-skinny
.Ve
.SH "REPOSITORY"
.IX Header "REPOSITORY"
.Vb 1
\&  git clone git://github.com/nekokak/p5\-teng.git
.Ve
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2010, the Teng \*(L"\s-1AUTHOR\s0\*(R". All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
