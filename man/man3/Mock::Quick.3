.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mock::Quick 3"
.TH Mock::Quick 3 "2014-04-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mock::Quick \- Quickly mock objects and classes, even temporarily replace them,
side\-effect free.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mock-Quick is here to solve the current problems with Mocking libraries.
.PP
There are a couple Mocking libraries available on \s-1CPAN\s0. The primary problems
with these libraries include verbose syntax, and most importantly side-effects.
Some Mocking libraries expect you to mock a specific class, and will unload it
then redefine it. This is particularily a problem if you only want to override
a class on a lexical level.
.PP
Mock-Object provides a declarative mocking interface that results in a very
concise, but clear syntax. There are seperate facilities for mocking object
instances, and classes. You can quickly create an instance of an object with
custom attributes and methods. You can also quickly create an anonymous class,
optionally inhereting from another, with whatever methods you desire.
.PP
Mock-Object also provides a tool that provides an \s-1OO\s0 interface to overriding
methods in existing classes. This tool also allows for the restoration of the
original class methods. Best of all this is a localized tool, when your control
object falls out of scope the original class is restored.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "\s-1MOCKING\s0 \s-1OBJECTS\s0"
.IX Subsection "MOCKING OBJECTS"
.Vb 1
\&    use Mock::Quick;
\&
\&    my $obj = qobj(
\&        foo => \*(Aqbar\*(Aq,            # define attribute
\&        do_it => qmeth { ... },  # define method
\&        ...
\&    );
\&
\&    is( $obj\->foo, \*(Aqbar\*(Aq );
\&    $obj\->foo( \*(Aqbaz\*(Aq );
\&    is( $obj\->foo, \*(Aqbaz\*(Aq );
\&
\&    $obj\->do_it();
\&
\&    # define the new attribute automatically
\&    $obj\->bar( \*(Aqxxx\*(Aq );
\&
\&    # define a new method on the fly
\&    $obj\->baz( qmeth { ... });
\&
\&    # remove an attribute or method
\&    $obj\->baz( qclear() );
.Ve
.SS "\s-1STRICTER\s0 \s-1MOCK\s0"
.IX Subsection "STRICTER MOCK"
.Vb 1
\&    use Mock::Quick;
\&
\&    my $obj = qstrict(
\&        foo => \*(Aqbar\*(Aq,            # define attribute
\&        do_it => qmeth { ... },  # define method
\&        ...
\&    );
\&
\&    is( $obj\->foo, \*(Aqbar\*(Aq );
\&    $obj\->foo( \*(Aqbaz\*(Aq );
\&    is( $obj\->foo, \*(Aqbaz\*(Aq );
\&
\&    $obj\->do_it();
\&
\&    # remove an attribute or method
\&    $obj\->baz( qclear() );
.Ve
.PP
You can no longer auto-vivify accessors and methods in strict mode:
.PP
.Vb 2
\&    # Cannot define the new attribute automatically
\&    dies_ok { $obj\->bar( \*(Aqxxx\*(Aq ) };
\&
\&    # Cannot define a new method on the fly
\&    dies_ok { $obj\->baz( qmeth { ... }) };
.Ve
.PP
In order to add methods/accessors you need to create a control object.
.SS "\s-1CONTROL\s0 \s-1OBJECTS\s0"
.IX Subsection "CONTROL OBJECTS"
Control objects are objects that let you interface a mocked object. They let
you add attributes and methods, or even clear them. This is unnecessary unless
you use strict mocking, or choose not to import \fIqmeth()\fR and \fIqclear()\fR.
.IP "Take Control" 4
.IX Item "Take Control"
.Vb 1
\&    my $control = qcontrol( $obj );
.Ve
.IP "Add Attributes" 4
.IX Item "Add Attributes"
.Vb 4
\&    $control\->set_attributes(
\&        foo => \*(Aqbar\*(Aq,
\&        ...
\&    );
.Ve
.IP "Add Methods" 4
.IX Item "Add Methods"
.Vb 4
\&    $control\->set_methods(
\&        do_it => sub { ... }, # No need to use qmeth()
\&        ...
\&    );
.Ve
.IP "Clear Attributes/Methods" 4
.IX Item "Clear Attributes/Methods"
.Vb 1
\&    $control\->clear( qw/foo do_it .../ );
.Ve
.IP "Toggle strict" 4
.IX Item "Toggle strict"
.Vb 1
\&    $control\->strict( $BOOL );
.Ve
.IP "Create With Control" 4
.IX Item "Create With Control"
.Vb 4
\&    my $obj = qobj ...;
\&    my $obj = qstrict ...;
\&    my ( $obj,  $control  ) = qobjc ...;
\&    my ( $sobj, $scontrol ) = qstrictc ...;
.Ve
.SS "\s-1MOCKING\s0 \s-1CLASSES\s0"
.IX Subsection "MOCKING CLASSES"
\&\fBNote:\fR the control object returned here is of type Mock::Quick::Class,
wheras control objects for qobj style objects are of
Mock::Quick::Object::Control.
.PP
\fI\s-1IMPLEMENT\s0 A \s-1CLASS\s0\fR
.IX Subsection "IMPLEMENT A CLASS"
.PP
This will implement a class at the namespace provided via the \-implement
argument. The class must not already be loaded. Once complete the real class
will be prevented from loading until you call \fIundefine()\fR on the control object.
.PP
.Vb 1
\&    use Mock::Quick;
\&
\&    my $control = qclass(
\&        \-implement => \*(AqMy::Package\*(Aq,
\&
\&        # Insert a generic new() method (blessed hash)
\&        \-with_new => 1,
\&
\&        # Inheritance
\&        \-subclass => \*(AqSome::Class\*(Aq,
\&        # Can also do
\&        \-subclass => [ \*(AqClass::A\*(Aq, \*(AqClass::B\*(Aq ],
\&
\&        # generic get/set attribute methods.
\&        \-attributes => [ qw/a b c d/ ],
\&
\&        # Method that simply returns a value.
\&        simple => \*(Aqvalue\*(Aq,
\&
\&        # Custom method.
\&        method => sub { ... },
\&    );
\&
\&    my $obj = $control\->package\->new;
\&    # OR
\&    my $obj = My::Package\->new;
\&
\&    # Override a method
\&    $control\->override( foo => sub { ... });
\&
\&    # Restore it to the original
\&    $control\->restore( \*(Aqfoo\*(Aq );
\&
\&    # Remove the namespace we created, which would allow the real thing to load
\&    # in a require or use statement.
\&    $control\->undefine();
.Ve
.PP
You can also use the \fIqimplement()\fR method instead of qclass:
.PP
.Vb 1
\&    use Mock::Quick;
\&
\&    my $control = qimplement \*(AqSome::Package\*(Aq => ( %args );
.Ve
.PP
\fI\s-1ANONYMOUS\s0 \s-1MOCKED\s0 \s-1CLASS\s0\fR
.IX Subsection "ANONYMOUS MOCKED CLASS"
.PP
This is if you just need to generate a class where the package name does not
matter. This is done when the \-takeover and \-implement arguments are both
ommited.
.PP
.Vb 1
\&    use Mock::Quick;
\&
\&    my $control = qclass(
\&        # Insert a generic new() method (blessed hash)
\&        \-with_new => 1,
\&
\&        # Inheritance
\&        \-subclass => \*(AqSome::Class\*(Aq,
\&        # Can also do
\&        \-subclass => [ \*(AqClass::A\*(Aq, \*(AqClass::B\*(Aq ],
\&
\&        # generic get/set attribute methods.
\&        \-attributes => [ qw/a b c d/ ],
\&
\&        # Method that simply returns a value.
\&        simple => \*(Aqvalue\*(Aq,
\&
\&        # Custom method.
\&        method => sub { ... },
\&    );
\&
\&    my $obj = $control\->package\->new;
\&
\&    # Override a method
\&    $control\->override( foo => sub { ... });
\&
\&    # Restore it to the original
\&    $control\->restore( \*(Aqfoo\*(Aq );
\&
\&    # Remove the anonymous namespace we created.
\&    $control\->undefine();
.Ve
.PP
\fI\s-1TAKING\s0 \s-1OVER\s0 \s-1EXISTING/LOADED\s0 \s-1CLASSES\s0\fR
.IX Subsection "TAKING OVER EXISTING/LOADED CLASSES"
.PP
.Vb 1
\&    use Mock::Quick;
\&
\&    my $control = qtakeover \*(AqSome::Package\*(Aq => ( %overrides );
\&
\&    # Override a method
\&    $control\->override( foo => sub { ... });
\&
\&    # Restore it to the original
\&    $control\->restore( \*(Aqfoo\*(Aq );
\&
\&    # Destroy the control object and completely restore the original class
\&    # Some::Package.
\&    $control = undef;
.Ve
.PP
You can also do this through \fIqclass()\fR:
.PP
.Vb 1
\&    use Mock::Quick;
\&
\&    my $control = qclass(
\&        \-takeover => \*(AqSome::Package\*(Aq,
\&        %overrides
\&    );
.Ve
.SH "METRICS"
.IX Header "METRICS"
All control objects have a 'metrics' method. The metrics method returns a hash
where keys are method names, and values are the number of times the method has
been called. When a method is altered or removed the key is deleted.
.PP
Metrics only apply to mocked methods. When you takeover an already loaded class
metrics will only track overriden methods.
.SH "EXPORTS"
.IX Header "EXPORTS"
Mock-Quick uses Exporter::Declare. This allows for exports to be prefixed or renamed.
See \*(L"\s-1RENAMING\s0 \s-1IMPORTED\s0 \s-1ITEMS\s0\*(R" in Exporter::Declare for more information.
.ie n .IP "$obj = qobj( attribute => value, ... )" 4
.el .IP "\f(CW$obj\fR = qobj( attribute => value, ... )" 4
.IX Item "$obj = qobj( attribute => value, ... )"
.PD 0
.ie n .IP "( $obj, $control ) = qobjc( attribute => value, ... )" 4
.el .IP "( \f(CW$obj\fR, \f(CW$control\fR ) = qobjc( attribute => value, ... )" 4
.IX Item "( $obj, $control ) = qobjc( attribute => value, ... )"
.PD
Create an object. Every possible attribute works fine as a get/set accessor.
You can define other methods using qmeth {...} and assigning that to an
attribute. You can clear a method using \fIqclear()\fR as an argument.
.Sp
See Mock::Quick::Object for more.
.ie n .IP "$obj = qstrict( attribute => value, ... )" 4
.el .IP "\f(CW$obj\fR = qstrict( attribute => value, ... )" 4
.IX Item "$obj = qstrict( attribute => value, ... )"
.PD 0
.ie n .IP "( $obj, $control ) = qstrictc( attribute => value, ... )" 4
.el .IP "( \f(CW$obj\fR, \f(CW$control\fR ) = qstrictc( attribute => value, ... )" 4
.IX Item "( $obj, $control ) = qstrictc( attribute => value, ... )"
.PD
Create a stricter object, get/set accessors will not autovivify into existance
for undefined attributes.
.ie n .IP "$control = qclass( \-config => ..., name => $value || sub { ... }, ... )" 4
.el .IP "\f(CW$control\fR = qclass( \-config => ..., name => \f(CW$value\fR || sub { ... }, ... )" 4
.IX Item "$control = qclass( -config => ..., name => $value || sub { ... }, ... )"
Define an anonymous package with the desired methods and specifications.
.Sp
See Mock::Quick::Class for more.
.ie n .IP "$control = qclass( \-takeover => $package, %overrides )" 4
.el .IP "\f(CW$control\fR = qclass( \-takeover => \f(CW$package\fR, \f(CW%overrides\fR )" 4
.IX Item "$control = qclass( -takeover => $package, %overrides )"
.PD 0
.ie n .IP "$control = qtakeover( $package, %overrides );" 4
.el .IP "\f(CW$control\fR = qtakeover( \f(CW$package\fR, \f(CW%overrides\fR );" 4
.IX Item "$control = qtakeover( $package, %overrides );"
.PD
Take over an existing class.
.Sp
See Mock::Quick::Class for more.
.ie n .IP "$control = qimplement( $package, \-config => ..., name => $value || sub { ... }, ... )" 4
.el .IP "\f(CW$control\fR = qimplement( \f(CW$package\fR, \-config => ..., name => \f(CW$value\fR || sub { ... }, ... )" 4
.IX Item "$control = qimplement( $package, -config => ..., name => $value || sub { ... }, ... )"
.PD 0
.ie n .IP "$control = qclass( \-implement => $package, ... )" 4
.el .IP "\f(CW$control\fR = qclass( \-implement => \f(CW$package\fR, ... )" 4
.IX Item "$control = qclass( -implement => $package, ... )"
.PD
Implement the given package to specifications, altering \f(CW%INC\fR so that the real
class will not load. Destroying the control object will once again allow the
original to load.
.IP "\fIqclear()\fR" 4
.IX Item "qclear()"
Returns a special reference that when used as an argument, will cause
Mock::Quick::Object methods to be cleared.
.ie n .IP "qmeth { my $self = shift; ... }" 4
.el .IP "qmeth { my \f(CW$self\fR = shift; ... }" 4
.IX Item "qmeth { my $self = shift; ... }"
Define a method for an Mock::Quick::Object instance.
.Sp
default_export qcontrol   => sub { Mock::Quick::Object::Control\->new( \f(CW@_\fR ) };
.SH "AUTHORS"
.IX Header "AUTHORS"
Chad Granum exodist7@gmail.com
.PP
Ben Hengst notbenh@cpan.org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Contributors are listed as authors in modules they have touched.
.IP "Ben Hengst notbenh@cpan.org" 4
.IX Item "Ben Hengst notbenh@cpan.org"
.PD 0
.IP "Glen Hinkle glen@empireenterprises.com" 4
.IX Item "Glen Hinkle glen@empireenterprises.com"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2011 Chad Granum
.PP
Mock-Quick is free software; Standard perl licence.
.PP
Mock-Quick is distributed in the hope that it will be useful, but \s-1WITHOUT\s0 \s-1ANY\s0
\&\s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A
\&\s-1PARTICULAR\s0 \s-1PURPOSE\s0. See the license for more details.
