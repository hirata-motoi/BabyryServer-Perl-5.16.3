.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mock::Quick::Class 3"
.TH Mock::Quick::Class 3 "2014-04-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mock::Quick::Class \- Class mocking for Mock::Quick
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Provides class mocking for Mock::Quick
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "\s-1IMPLEMENT\s0 A \s-1CLASS\s0"
.IX Subsection "IMPLEMENT A CLASS"
This will implement a class at the namespace provided via the \-implement
argument. The class must not already be loaded. Once complete the real class
will be prevented from loading until you call \fIundefine()\fR on the control object.
.PP
.Vb 1
\&    use Mock::Quick::Class;
\&
\&    my $control = Mock::Quick::Class\->new(
\&        \-implement => \*(AqMy::Package\*(Aq,
\&
\&        # Insert a generic new() method (blessed hash)
\&        \-with_new => 1,
\&
\&        # Inheritance
\&        \-subclass => \*(AqSome::Class\*(Aq,
\&        # Can also do
\&        \-subclass => [ \*(AqClass::A\*(Aq, \*(AqClass::B\*(Aq ],
\&
\&        # generic get/set attribute methods.
\&        \-attributes => [ qw/a b c d/ ],
\&
\&        # Method that simply returns a value.
\&        simple => \*(Aqvalue\*(Aq,
\&
\&        # Custom method.
\&        method => sub { ... },
\&    );
\&
\&    my $obj = $control\->package\->new;
\&    # OR
\&    my $obj = My::Package\->new;
\&
\&    # Override a method
\&    $control\->override( foo => sub { ... });
\&
\&    # Restore it to the original
\&    $control\->restore( \*(Aqfoo\*(Aq );
\&
\&    # Remove the namespace we created, which would allow the real thing to load
\&    # in a require or use statement.
\&    $control\->undefine();
.Ve
.PP
You can also use the 'implement' method instead of new:
.PP
.Vb 1
\&    use Mock::Quick::Class;
\&
\&    my $control = Mock::Quick::Class\->implement(
\&        \*(AqSome::Package\*(Aq,
\&        %args
\&    );
.Ve
.SS "\s-1ANONYMOUS\s0 \s-1MOCKED\s0 \s-1CLASS\s0"
.IX Subsection "ANONYMOUS MOCKED CLASS"
This is if you just need to generate a class where the package name does not
matter. This is done when the \-takeover and \-implement arguments are both
ommited.
.PP
.Vb 1
\&    use Mock::Quick::Class;
\&
\&    my $control = Mock::Quick::Class\->new(
\&        # Insert a generic new() method (blessed hash)
\&        \-with_new => 1,
\&
\&        # Inheritance
\&        \-subclass => \*(AqSome::Class\*(Aq,
\&        # Can also do
\&        \-subclass => [ \*(AqClass::A\*(Aq, \*(AqClass::B\*(Aq ],
\&
\&        # generic get/set attribute methods.
\&        \-attributes => [ qw/a b c d/ ],
\&
\&        # Method that simply returns a value.
\&        simple => \*(Aqvalue\*(Aq,
\&
\&        # Custom method.
\&        method => sub { ... },
\&    );
\&
\&    my $obj = $control\->package\->new;
\&
\&    # Override a method
\&    $control\->override( foo => sub { ... });
\&
\&    # Restore it to the original
\&    $control\->restore( \*(Aqfoo\*(Aq );
\&
\&    # Remove the anonymous namespace we created.
\&    $control\->undefine();
.Ve
.SS "\s-1TAKING\s0 \s-1OVER\s0 \s-1EXISTING/LOADED\s0 \s-1CLASSES\s0"
.IX Subsection "TAKING OVER EXISTING/LOADED CLASSES"
.Vb 1
\&    use Mock::Quick::Class;
\&
\&    my $control = Mock::Quick::Class\->takeover( \*(AqSome::Package\*(Aq );
\&
\&    # Override a method
\&    $control\->override( foo => sub { ... });
\&
\&    # Restore it to the original
\&    $control\->restore( \*(Aqfoo\*(Aq );
\&
\&    # Destroy the control object and completely restore the original class
\&    # Some::Package.
\&    $control = undef;
.Ve
.PP
You can also do this through \fInew()\fR
.PP
.Vb 1
\&    use Mock::Quick::Class;
\&
\&    my $control = Mock::Quick::Class\->new(
\&        \-takeover => \*(AqSome::Package\*(Aq,
\&        %overrides
\&    );
.Ve
.SH "ACCESSING THE CONTROL OBJECY"
.IX Header "ACCESSING THE CONTROL OBJECY"
While the control object exists, it can be accessed via
\&\f(CW\*(C`YOUR::PACKAGE\-\*(C'\fR\s-1\fIMQ_CONTROL\s0()\fR>. It is important to note that this method will
dissapear whenever the control object you track falls out of scope.
.PP
Example (taken from Class.t):
.PP
.Vb 5
\&    $obj = $CLASS\->new( \-takeover => \*(AqBaz\*(Aq );
\&    $obj\->override( \*(Aqfoo\*(Aq, sub {
\&        my $class = shift;
\&        return "PREFIX: " . $class\->MQ_CONTROL\->original( \*(Aqfoo\*(Aq )\->();
\&    });
\&
\&    is( Baz\->foo, "PREFIX: foo", "Override and accessed original through MQ_CONTROL" );
\&    $obj = undef;
\&
\&    is( Baz\->foo, \*(Aqfoo\*(Aq, \*(Aqoriginal\*(Aq );
\&    ok( !Baz\->can(\*(AqMQ_CONTROL\*(Aq), "Removed control" );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$package = $obj\->\fIpackage()\fR" 4
.el .IP "\f(CW$package\fR = \f(CW$obj\fR\->\fIpackage()\fR" 4
.IX Item "$package = $obj->package()"
Get the name of the package controlled by this object.
.ie n .IP "$bool = $obj\->\fIis_takeover()\fR" 4
.el .IP "\f(CW$bool\fR = \f(CW$obj\fR\->\fIis_takeover()\fR" 4
.IX Item "$bool = $obj->is_takeover()"
Check if the control object was created to takeover an existing class.
.ie n .IP "$bool = $obj\->\fIis_implement()\fR" 4
.el .IP "\f(CW$bool\fR = \f(CW$obj\fR\->\fIis_implement()\fR" 4
.IX Item "$bool = $obj->is_implement()"
Check if the control object was created to implement a class.
.ie n .IP "$data = $obj\->\fImetrics()\fR" 4
.el .IP "\f(CW$data\fR = \f(CW$obj\fR\->\fImetrics()\fR" 4
.IX Item "$data = $obj->metrics()"
Returns a hash where keys are method names, and values are the number of times
the method has been called. When a method is altered or removed the key is
deleted.
.ie n .IP "$obj\->override( name => sub { ... })" 4
.el .IP "\f(CW$obj\fR\->override( name => sub { ... })" 4
.IX Item "$obj->override( name => sub { ... })"
Override a method.
.ie n .IP "$obj\->original( $name );" 4
.el .IP "\f(CW$obj\fR\->original( \f(CW$name\fR );" 4
.IX Item "$obj->original( $name );"
Get the original method (coderef). Note: The first time this is called it find
and remembers the value of package\->can( \f(CW$name\fR ). This means that if you modify
or replace the method without using Mock::Quick before this is called, it will
have the updated method, not the true original.
.Sp
The \fIoverride()\fR method will call this first to ensure the original method is
cached and available for \fIrestore()\fR. Once a value is set it is never replaced or
cleared.
.ie n .IP "$obj\->restore( $name )" 4
.el .IP "\f(CW$obj\fR\->restore( \f(CW$name\fR )" 4
.IX Item "$obj->restore( $name )"
Restore a method (Resets metrics)
.ie n .IP "$obj\->\fIundefine()\fR" 4
.el .IP "\f(CW$obj\fR\->\fIundefine()\fR" 4
.IX Item "$obj->undefine()"
Undefine the package controlled by the control.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "Chad Granum exodist7@gmail.com" 4
.IX Item "Chad Granum exodist7@gmail.com"
.PD 0
.IP "Glen Hinkle glen@empireenterprises.com" 4
.IX Item "Glen Hinkle glen@empireenterprises.com"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2011 Chad Granum
.PP
Mock-Quick is free software; Standard perl licence.
.PP
Mock-Quick is distributed in the hope that it will be useful, but \s-1WITHOUT\s0 \s-1ANY\s0
\&\s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A
\&\s-1PARTICULAR\s0 \s-1PURPOSE\s0. See the license for more details.
