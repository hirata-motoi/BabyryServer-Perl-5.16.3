.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Util::JA 3"
.TH Data::Util::JA 3 "2014-03-06" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Util::JA \- XXXXXXXXXXXXXXXXXXXX
.SH "VERSION"
.IX Header "VERSION"
This document describes Data::Util version 0.63
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Data::Util qw(:validate);
\&
\&        sub foo{
\&                # they will die if invalid values are supplied
\&                my $sref = scalar_ref(shift);
\&                my $aref = array_ref(shift);
\&                my $href = hash_ref(shift);
\&                my $cref = code_ref(shift);
\&                my $gref = glob_ref(shift);
\&                my $rref = regex_ref(shift);
\&                my $obj  = instance(shift, \*(AqFoo\*(Aq);
\&                # ...
\&        }
\&
\&        use Data::Util qw(:check);
\&
\&        sub bar{
\&                my $x = shift;
\&                if(is_scalar_ref $x){
\&                        # $x is an array reference
\&                }
\&                # ...
\&                elsif(is_instance $x, \*(AqFoo\*(Aq){
\&                        # $x is an instance of Foo
\&                }
\&                # ...
\&        }
\&
\&        # miscelaneous
\&        use Data::Util qw(:all);
\&
\&        my $x = anon_scalar();
\&        $x = anon_scalar($x); # OK
\&
\&        my $stash = get_stash(\*(AqFoo\*(Aq);
\&
\&        install_subroutine(\*(AqFoo\*(Aq,
\&                hello  => sub{ "Hello!\en" },
\&                goodby => sub{ "Goodby!\en" },
\&        );
\&
\&        print Foo::hello(); # Hello!
\&
\&        my($pkg, $name) = get_code_info(\e&Foo::hello); # => (\*(AqFoo\*(Aq, \*(Aqhello\*(Aq)
\&        my $fqn         = get_code_info(\e&Foo::hello); # =>  \*(AqFoo::Hello\*(Aq
\&        my $code        = get_code_ref($fqn);          # => \e&Foo::hello
\&
\&        uninstall_subroutine(\*(AqFoo\*(Aq, qw(hello goodby));
\&
\&        print neat("Hello!\en"); # => "Hello!\en"
\&        print neat(3.14);       # => 3.14
\&        print neat(undef);      # => undef
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
XXXXXXXXXSXPure PerlXXXXXXXXXXXCXXXXXXXX
XXXXXSXXXXXXXXXXXXXXPure PerlXXXXXXXXXXXXXX
\&\s-1XXXXXXX\s0\f(CW\*(C`DATA_UTIL_PUREPERL\*(C'\fRXXXXXXXXXXXXXXXPure Perl
\&\s-1XXXXXXXXXXXXXXXXXXX\s0
.PP
\&\s-1XSXXXXXXXXXXXXXXXXXXX\s0
Pure PerlXXXXXXXX2XXX10XXXXXXXXXXXX
XXXXSXXXXXXXXXXXXXXXXXXXXXXXPure PerlXXXX
\&\s-1XXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
\&\s-1XXXXXXXXXXXX\s0\fIbenchmark/\fR\s-1XXXXXXXXXXXXXXXXXXX\s0
.SH "INTERFACE"
.IX Header "INTERFACE"
.SS "Check functions"
.IX Subsection "Check functions"
\&\s-1XXXXXXXX\s0\f(CW\*(C`:check\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0\f(CW\*(C`${}\*(C'\fRX
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_scalar_ref(value)" 4
.IX Item "is_scalar_ref(value)"
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_array_ref(value)" 4
.IX Item "is_array_ref(value)"
\&\s-1XXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_hash_ref(value)" 4
.IX Item "is_hash_ref(value)"
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_code_ref(value)" 4
.IX Item "is_code_ref(value)"
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_glob_ref(value)" 4
.IX Item "is_glob_ref(value)"
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_regex_ref(value)" 4
.IX Item "is_regex_ref(value)"
\&\f(CW\*(C`qr//\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_instance(value, class)" 4
.IX Item "is_instance(value, class)"
\&\fIclass\fR\s-1XXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\f(CW\*(C`Scalar::Util::blessed($value) && $value\->isa($class)\*(C'\fR\s-1XXXXXXX\s0
\&\s-1XXXXXXX\s0
.Sp
\&\fIclass\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_invocant(value)" 4
.IX Item "is_invocant(value)"
\&\fIvalue\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_value(value)" 4
.IX Item "is_value(value)"
\&\fIvalue\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXXX\s0(\s-1XXX\s0\f(CW\*(C`is_string\*(C'\fR/\f(CW\*(C`is_number()\*(C'\fR/\f(CW\*(C`is_integer()\*(C'\fR)XX
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXX\s0\fIvalue\fR\s-1XXXXX/XXX/XXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_string(value)" 4
.IX Item "is_string(value)"
\&\fIvalue\fR\s-1XXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXX1XXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\f(CW\*(C`do{ is_value($value) && length($value) > 0 }\*(C'\fR\s-1XXXXXX\s0
.Sp
\&\s-1XXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_number(value)" 4
.IX Item "is_number(value)"
\&\fIvalue\fR\s-1XXXXXXXXXXXXXXXX\s0
\&\s-1XXX\s0\fB\s-1XX\s0\fR\s-1XXXXXXXXXXX\s0(\s-1XXXX\s0\f(CW\*(C`sprintf \*(Aq%g\*(Aq, $value\*(C'\fRX
\&\s-1XXXXXXXXXXXXXXXXXXX\s0
XXPerlXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.Sp
\&\s-1XXXXXXXXXX\s0\f(CW\*(C`Scalar::Util::looks_like_number()\*(C'\fR\s-1XXXXX\s0
\&\f(CW\*(C`Infinity\*(C'\fRX\f(CW\*(C`NaN\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\f(CW"0 but true"\fR\s-1XXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXXXXXXXXXXXXXXXXXXXXX\s0
.IP "is_integer(value)" 4
.IX Item "is_integer(value)"
\&\fIvalue\fR\s-1XXXXXXXXXXXXXXXXXXX\s0\f(CW\*(C`is_number()\*(C'\fR\s-1XXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXXXXXXXXXXXXXXXXXXXXX\s0
.SS "Validating functions"
.IX Subsection "Validating functions"
\&\s-1XXXXX\s0\f(CW\*(C`:validate\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXX\s0
.PP
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "scalar_ref(value)" 4
.IX Item "scalar_ref(value)"
\&\s-1XXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "array_ref(value)" 4
.IX Item "array_ref(value)"
\&\s-1XXXXXXXXXXXXXXXXXXXXX\s0
.IP "hash_ref(value)" 4
.IX Item "hash_ref(value)"
\&\s-1XXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "code_ref(value)" 4
.IX Item "code_ref(value)"
\&\s-1XXXXXXXXXXXXXXXXXXXXXX\s0
.IP "glob_ref(value)" 4
.IX Item "glob_ref(value)"
\&\s-1XXXXXXXXXXXXXXXXXXXXXX\s0
.IP "regex_ref(value)" 4
.IX Item "regex_ref(value)"
\&\f(CW\*(C`qr//\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "instance(value, class)" 4
.IX Item "instance(value, class)"
\&\fIclass\fR\s-1XXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\fIclass\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "invocant(value)" 4
.IX Item "invocant(value)"
\&\fIvalue\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\fIvalue\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXX\s0\f(CW"::Foo"\fRX\f(CW"main::Foo"\fR\s-1XXXXX\s0\f(CW"Foo"\fR\s-1XXXXXX\s0
.SS "Micellaneous utilities"
.IX Subsection "Micellaneous utilities"
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "\fIanon_scalar()\fR" 4
.IX Item "anon_scalar()"
\&\f(CW\*(C`undef\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXX\s0
.IP "anon_scalar(value)" 4
.IX Item "anon_scalar(value)"
\&\fIvalue\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXX\s0\f(CW\*(C`do{ my $tmp = $value; \e$value; }\*(C'\fR\s-1XXXXXXXXXXXX\s0
.IP "neat(value)" 4
.IX Item "neat(value)"
\&\fIvalue\fR\s-1XXXXXXXXXXXXXXXXXXXXXX\s0
\&\f(CW\*(C`do{ defined($value) ? qq{"$value"} : \*(Aqundef\*(Aq }\*(C'\fR\s-1XXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXX\s0
.IP "get_stash(invocant)" 4
.IX Item "get_stash(invocant)"
\&\fIinvodant\fR\s-1XXXXXX\s0 \fBstash\fR\s-1XXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\fIinvocant\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXX\s0
.Sp
\&\fIinvocant\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXX\s0
.IP "install_subroutine(package, name => subr [, ...])" 4
.IX Item "install_subroutine(package, name => subr [, ...])"
\&\s-1XXXXXX\s0\fIsubr\fRX\fIpackage\fRX\fIname\fR\s-1XXXXXXXXXXXXX\s0
.Sp
\&\f(CW\*(C`do{ no strict \*(Aqrefs\*(Aq; *{$package.\*(Aq::\*(Aq.$name} = \e&subr; }\*(C'\fR\s-1XXXXXXX\s0
\&\s-1XXXXXXXXXXX\s0\fIsubr\fR\s-1XXXXXXXXXXXXXX\s0\fIpackage\fRX
\&\s-1XXXXXXXXXX\s0\fI&package::name\fR\s-1XXXXXXXX\s0(XXXXPure PerlXXXXXXXXXXXXXXXXXXXXXXXX)X
.Sp
\&\s-1XXXXXXXXXXXXXXXXXXXX\s0\f(CW\*(C`no warnings \*(Aqredefine\*(Aq\*(C'\fR
\&\s-1XXXXXXXXXXXXXXXX\s0
.Sp
.Vb 2
\&        no warnings \*(Aqredefine\*(Aq;
\&        install_subrouitne($package, $name => $subr);
.Ve
.Sp
\&\fIpackage\fRX\fIname\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\fIsubr\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXXXX\s0\f(CW\*(C`no strict \*(Aqrefs\*(Aq\*(C'\fR\s-1XXXXXXXXXX\s0\fBstrictXXXXXX\fRXXXXXXXXXXXXXstrictXXXXXXXXXXXXXXXXXXXXXXX
.Sp
.Vb 2
\&        my $property = ...;
\&        # ...
\&
\&        no strict \*(Aqrefs\*(Aq;
\&        # simple read\-only accessor
\&        *{$pkg . \*(Aq::\*(Aq . $sub_name} = sub{
\&                my($self) = @_;
\&                return $self\->{$property};
\&        }
.Ve
.Sp
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXX\s0\f(CW$self\fR\s-1XXXXXXXXXXXXXXXXXXXXX\s0
\&\f(CW\*(C`$self\->{$property}\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXX\s0\f(CW\*(C`undef\*(C'\fR\s-1XXXXXXXXXX\s0
\&\f(CW\*(C`<use strict \*(Aqrefs\*(Aq\*(C'\fR>\s-1XXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
XXXXXXstrictXXXXXXXXXXXXXXXXXXXXXXXXX
\&\f(CW\*(C`use strict\*(C'\fR\s-1XXXXXXXXXXXXXX\s0
.Sp
.Vb 6
\&        no strict \*(Aqrefs\*(Aq;
\&        *{$pkg . \*(Aq::\*(Aq . $sub_name} = sub{
\&                use strict \*(Aqrefs\*(Aq;
\&                my($self) = @_;
\&                return $self\->{$property};
\&        }
.Ve
.Sp
\&\s-1XXXX\s0\f(CW\*(C`install_subroutine()\*(C'\fR\s-1XXXXX\s0\f(CW\*(C`strict\*(C'\fR\s-1XXXXXXXXXXXXXXX\s0
.Sp
.Vb 6
\&        install_subroutine $pkg => (
\&                $sub_name => sub{
\&                        my($self) = @_;
\&                        return $self\->{$property};
\&                },
\&        );
.Ve
.Sp
XXstrictXXXXXXXXXXXX\*(L"18.10\*(R" in \*(L"PerlXXXXXXXXX\*(R"
\&\fI\s-1XXXXXXX\s0 \- \s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0\fR \s-1XXXXXXXXX\s0
.IP "uninstall_subroutine(package, name [=> code], ...)" 4
.IX Item "uninstall_subroutine(package, name [=> code], ...)"
\&\s-1XXXXXX\s0\fIname\fR\s-1XXXXXX\s0\fIpackage\fR\s-1XXXXXXXX\s0
.Sp
\&\f(CW\*(C`undef &subr\*(C'\fRX\f(CW&subr\fR\s-1XXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXX\s0\f(CW\*(C`uninstall_subroutine\*(C'\fR\s-1XXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXX\s0
\&\s-1XXXXX\s0\f(CW\*(C`namespace::clean\*(C'\fRX\f(CW\*(C`constant::lexical\*(C'\fR\s-1XXXXXXXXXXXXX\s0
.Sp
\&\fIname\fR\s-1XXXX\s0\fIcode\fR\s-1XXXXXXXXXXXX\s0\f(CW&package::name\fRX\fIcode\fR\s-1XXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
.Vb 2
\&        uninstall_subroutine($pkg, $name) if \e&{$pkg . \*(Aq::\*(Aq . $name} == $code;
\&        uninstall_subroutine($pkg, $name => $code);
.Ve
.Sp
\&\s-1XXXXX\s0\f(CW\*(C`Sub::Delete::delete_sub()\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXX\s0
.IP "get_code_info(subr)" 4
.IX Item "get_code_info(subr)"
\&\s-1XXXXXX\s0\fIsubr\fR\s-1XXXXXXXXXXXXXXXXXX\s0
\&\s-1XXX\s0\f(CW\*(C`Sub::Identify::get_code_info()\*(C'\fR\s-1XXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\fIsubr\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXX\s0\f(CW\*(C`undef\*(C'\fR\s-1XXXXXX\s0
.IP "get_code_ref(package, name)" 4
.IX Item "get_code_ref(package, name)"
\&\fI\e&package::name\fR\s-1XXXXXXXXXXXXXXX\s0
\&\s-1XXX\s0\f(CW\*(C`do{ no strict \*(Aqrefs\*(Aq; *{$package . \*(Aq::\*(Aq . $name}{CODE} }\*(C'\fR
\&\s-1XXXXXXXX\s0\fI\e&package::name\fR\s-1XXXXXXXXXX\s0
\&\fI*package::name\fR\s-1XXXXXXXX\s0
.Sp
\&\s-1XXXXXXX\s0\f(CW"\-create"\fR\s-1XXXXXX\s0\fI\e&package::name\fR\s-1XXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXX\s0
\&\s-1XXX\s0\f(CW\*(C`do{ no strict \*(Aqrefs\*(Aq; \e&{$package . \*(Aq::\*(Aq . $name} }\*(C'\fR\s-1XXXXXX\s0
.IP "curry(subr, args and/or placeholders)" 4
.IX Item "curry(subr, args and/or placeholders)"
\&\s-1XXXXXX\s0\fIsubr\fR\s-1XXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\fIargs and/or placeholders\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0\fIx\fR\s-1XXX\s0
\&\s-1XX\s0\f(CW\*(C`\ex\*(C'\fR\s-1XX\s0\f(CW\*(C`\ex\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\f(CW*_\fR\s-1XXXXXX\s0
.Sp
\&\s-1XXXXXXXX\s0\f(CW$closure\fRX\f(CW$curried\fR\s-1XXXXXXXXXXXXXXXXXXXX\s0
.Sp
.Vb 3
\&        my $class = \*(AqFoo\*(Aq;
\&        $closure = sub{ is_instance($_[0], $class) };
\&        $curried = curry \e&is_instance, \e0, $class;
\&
\&        $closure = sub{ install_subroutine($class, @_) };
\&        $curried = curry \e&install_subroutine, $class, *_;
.Ve
.Sp
\&\s-1XXX\s0\f(CW*_\fRX\f(CW\*(C`\ex\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXX\s0\f(CW\*(C`curry(\e&subr, *_, \e1)\->(0, 1, 2, 3)\*(C'\fR\s-1XXXXXXXXXX\s0
\&\f(CW\*(C`subr(2, 3, 1)\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\f(CW$_[0]\fR(\s-1XXX0\s0)XXXXXXXX
.Sp
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXXXXXXXXXXXX\s0Data::Util::Curry\s-1XXXXXX\s0
.IP "modify_subroutine(subr, modifier_type => [subroutines], ...)" 4
.IX Item "modify_subroutine(subr, modifier_type => [subroutines], ...)"
\&\s-1XXXXXX\s0\fIsubr\fRX\fImodifier_type\fR\s-1XXXXXX\s0\fIsubroutines\fR\s-1XXXXX\s0
\&\s-1XXXX\s0\fImodified_subr\fR\s-1XXXXXXXX\s0
.Sp
\&\fImodifier_type\fR\s-1XX\s0\f(CW\*(C`before\*(C'\fR, \f(CW\*(C`around\*(C'\fR, \f(CW\*(C`after\*(C'\fR\s-1XXXX\s0\f(CW\*(C`before\*(C'\fRX
\&\fIsubr\fR\s-1XXXXXXXX\s0\f(CW\*(C`after\*(C'\fRX\fIsubr\fR\s-1XXXXXXX\s0\fImodified_subr\fRX
\&\s-1XXXXXXXXXXXXXXXX\s0\f(CW\*(C`before\*(C'\fRX\f(CW\*(C`after\*(C'\fR\s-1XXXXXXXXXXXX\s0
\&\f(CW\*(C`around\*(C'\fRX\fIsubr\fR\s-1XXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXXXXXXXXX\s0\f(CW\*(C`before\*(C'\fRX\f(CW\*(C`around\*(C'\fR\s-1XXXXXXXXXXXXXXXXXX\s0
(last\-defined\-first\-called)X\f(CW\*(C`after\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXX\s0(first\-defined\-first\-called)XXXXXXXXX\f(CW\*(C`subroutine_modifier()\*(C'\fR\s-1XXXX\s0
\&\s-1XXX\s0
.Sp
\&\s-1XXXXX\s0
.Sp
.Vb 6
\&        $modified = modify_subroutine(\e&foo, around => [sub{
\&                my $next = shift;
\&                do_something();
\&                goto &{$next}; # continuation
\&        }]);
\&        $modified\->();
\&
\&        $modified = modify_subroutine(\e&foo,
\&                before => \e@befores,
\&                around => \e@arounds,
\&                after  => \e@afters,
\&        );
\&        $modified\->();
.Ve
.Sp
\&\s-1XSXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXXXXXXXXXXXXXXXXXXX\s0\fIexample/lib/Method/Modifiers.pm\fR
(\f(CW\*(C`modify_subroutine()\*(C'\fR/\f(CW\*(C`subroutine_modifier()\*(C'\fR\s-1XXX\s0)XXXXXXX
\&\fIbenchmark/methext_bench.pl\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
.Vb 3
\&        with before modifier: 100% slower
\&        with after  modifier: 100% slower
\&        with around modifier: 200% slower
.Ve
.Sp
\&\s-1XXX\s0\f(CW\*(C`before\*(C'\fRX\f(CW\*(C`after\*(C'\fRX\f(CW\*(C`SUPER::\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXXXXXXXXX\s0\*(L"Method Modifiers\*(R" in Class::MOP::ClassX
\&\s-1XXXXXXXXXXX\s0Class::Method::Modifiers\s-1XXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXAPIXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXXXX\s0
.IP "subroutine_modifier(modified, modifier_type => subroutines, ...)" 4
.IX Item "subroutine_modifier(modified, modifier_type => subroutines, ...)"
\&\f(CW\*(C`modify_subroutine()\*(C'\fR\s-1XXXXX\s0\fImodified\fR\s-1XXXXXXX\s0
.Sp
\&\s-1XXX\s0\fImodified\fR\s-1XXXXXXXXXXX\s0\fImodified\fRX\f(CW\*(C`modify_subroutine()\*(C'\fRX
\&\s-1XXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
.Vb 3
\&        if(subroutine_modifier $subr){
\&                # $subrXXXXXXXXXXXX
\&        }
.Ve
.Sp
\&\fImodified\fRX\fImodifier_type\fR(\f(CW\*(C`before\*(C'\fR, \f(CW\*(C`around\*(C'\fR, \f(CW\*(C`after\*(C'\fR)
\&\s-1XXXXXXX\s0\fImodifier_type\fR\s-1XXXXXXXXXXXXXX\s0
.Sp
.Vb 1
\&        @befores = subroutine_modifier $modified, \*(Aqbefore\*(Aq;
.Ve
.Sp
\&\s-1XXXXXXXXXXXXXXXXXXXXXX\s0\fImodified\fRX\fImodifier_type\fRX
\&\s-1XXXXXXXXXXX\s0
.Sp
.Vb 1
\&        subroutine_modifier $modified, before => @befores;
.Ve
.IP "mkopt(input, moniker, require_unique, must_be)" 4
.IX Item "mkopt(input, moniker, require_unique, must_be)"
\&\fIinput\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXX\s0\f(CW\*(C`Data::OptList::mkopt()\*(C'\fR\s-1XXXXXXXXXXXXXX\s0\fImust_be\fRX
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
For example:
.Sp
.Vb 2
\&        $array_ref = mkopt([qw(foo bar), baz => [42]], \*(Aqmoniker\*(Aq);
\&        # $array_ref == [ [foo => undef], [bar => undef], baz => [42] ]
.Ve
.IP "mkopt_hash(input, moniker, must_be)" 4
.IX Item "mkopt_hash(input, moniker, must_be)"
\&\fIinput\fR\s-1XXXXXXXXXXXXXXXXXXXX\s0
.Sp
\&\s-1XXX\s0\f(CW\*(C`Data::OptList::mkopt_hash()\*(C'\fR\s-1XXXXXXXXXXXXXX\s0\fImust_be\fRX
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.Sp
For example:
.Sp
.Vb 2
\&        $hash_ref = mkopt([qw(foo bar), baz => [42]], \*(Aqmoniker\*(Aq);
\&        # $hash_ref == { foo => undef, bar => undef, baz => [42] }
.Ve
.SS "Error handling"
.IX Subsection "Error handling"
\&\s-1XXXXXXXXXXXXXXXXXXXXX\s0\f(CW\*(C`Data::Util::Error\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXX\s0
.PP
.Vb 3
\&        package Foo;
\&        use Data::Util::Error sub{ Foo::InvalidArgument\->throw(@_) };
\&        use Data::Util qw(:validate);
\&
\&        # ...
.Ve
.PP
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0\f(CW\*(C`Data::Util\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.SH "DISCUSSIONS"
.IX Header "DISCUSSIONS"
.SH "What is a X\-reference?"
.IX Header "What is a X-reference?"
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
\&\s-1XXXXXXXXXXX3XXXXXXXX\s0
.IP "1." 4
\&\f(CW\*(C`ref($x) eq \*(AqHASH\*(Aq\*(C'\fR
.IP "2." 4
\&\f(CW\*(C`Scalar::Util::reftype($x) eq \*(AqHASH\*(Aq\*(C'\fR
.IP "3." 4
\&\f(CW\*(C`overload::Method($x, \*(Aq%{}\*(Aq)\*(C'\fR
.PP
\&\f(CW\*(C`ref()\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
\&\f(CW\*(C`reftype()\*(C'\fRXXXXXXXXXXXXX$xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
\&\s-1XXX\s0\f(CW\*(C`overload::Method\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
XXXXX$xXXXXXXXXXXXXXXXXXXXXXX(\f(CW\*(C`$x\->{$key}\*(C'\fR)XXXXXXXXXXXX$xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
\&\s-1XXXXXXX\s0\f(CW\*(C`is_hash_ref()\*(C'\fR\s-1XXXXXXXXXXXXXXXXXXXXXX\s0\f(CW\*(C`Params::Util\*(C'\fRXXXXXXXXVersion 0.35XXXXXX\f(CW\*(C`P::U::_HASH\*(C'\fRX(1)XX\f(CW\*(C`P::U::_HASHLIKE\*(C'\fRX(2)X(3)\fIXXXXXXXXXXXXXXXXXXXXX\fR\|(1)\fIXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\fR\|(2)XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\f(CW\*(C`is_hash_ref()\*(C'\fRX(1)X(3)XXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
\&\s-1XXXXXX\s0\f(CW\*(C`is_hash_ref()\*(C'\fR\s-1XX\s0\f(CW\*(C`ref()\*(C'\fRX\f(CW\*(C`overload::Method()\*(C'\fR\s-1XXXXXXXXXXXXXXXXXX\s0\f(CW\*(C`is_scalar_ref()\*(C'\fRX\f(CW\*(C`is_array_ref()\*(C'\fRX\f(CW\*(C`is_code_ref()\*(C'\fRX\f(CW\*(C`is_glob_ref()\*(C'\fR\s-1XXXXXX\s0
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
.SS "\s-1DATA_UTIL_PUREPERL\s0"
.IX Subsection "DATA_UTIL_PUREPERL"
XXXXXXPure PerlXXXXXXXXXXXXXXX
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Perl 5.8.1 or later.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.PP
Please report any bugs or feature requests to the author.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
overload.
.PP
Scalar::Util.
.PP
Class::MOP.
.PP
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXSXXXXX\s0
\&\s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
Params::Util.
.PP
Sub::Install.
.PP
Sub::Identify.
.PP
Sub::Delete.
.PP
Sub::Curry.
.PP
Class::Method::Modifiers.
.PP
Data::OptList.
.SH "AUTHOR"
.IX Header "AUTHOR"
Goro Fuji (gfx) <gfuji(at)cpan.org>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2008\-2009, Goro Fuji (gfx) <gfuji(at)cpan.org>. Some rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
