.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::DBHResolver 3"
.TH DBIx::DBHResolver 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::DBHResolver \- Resolve database connection on the environment has many database servers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBIx::DBHResolver;
\&
\&  my $r = DBIx::DBHResolver\->new;
\&  $r\->config(+{
\&    connect_info => +{
\&      main_master => +{
\&        dsn => \*(Aqdbi:mysql:dbname=main;host=localhost\*(Aq,
\&        user => \*(Aqmaster_user\*(Aq, password => \*(Aq\*(Aq,
\&        attrs => +{ RaiseError => 1, AutoCommit => 0, },
\&      },
\&      main_slave => +{
\&        dsn => \*(Aqdbi:mysql:dbname=main;host=localhost\*(Aq,
\&        user => \*(Aqslave_user\*(Aq, password => \*(Aq\*(Aq,
\&        attrs => +{ RaiseError => 1, AutoCommit => 1, },
\&      }
\&    },
\&  });
\&
\&  my $dbh_master = $r\->connect(\*(Aqmain_master\*(Aq);
\&  $dbh_master\->do( \*(AqUPDATE people SET ...\*(Aq, undef, ... );
\&
\&  my $dbh_slave = $r\->connect(\*(Aqmain_slave\*(Aq);
\&  my $people = $dbh_slave\->selectrow_hashref( \*(AqSELECT * FROM people WHERE id = ?\*(Aq, undef, 20 );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::DBHResolver resolves database connection on the environment has many database servers.
The resolution algorithm is extensible and pluggable, because of this you can make custom strategy module easily.
.PP
This module can retrieve \s-1DBI\s0's database handle object or connection information (data source, user, credential...) by labeled name
and treat same cluster consists many nodes as one labeled name, choose fetching strategy.
.PP
DBIx::DBHResolver is able to use as instance or static class.
.SS "\s-1USING\s0 \s-1STRATEGY\s0, \s-1MAKING\s0 \s-1CUSTOM\s0 \s-1STRATEGY\s0"
.IX Subsection "USING STRATEGY, MAKING CUSTOM STRATEGY"
See DBIx::DBHResolver::Strategy::Key.
.SS "connect_info format"
.IX Subsection "connect_info format"
\&\fBconnect_info\fR is node information to connect it. Following fields are recognized.
.PP
.Vb 7
\&  my $connect_info = +{
\&    dsn => \*(Aqdbi:mysql:db=test\*(Aq,
\&    user => \*(Aqroot\*(Aq,
\&    password => \*(Aq\*(Aq,
\&    attrs => +{ RaiseError => 1, AutoCommit => 0 },
\&    opts => +{},
\&  };
.Ve
.IP "dsn" 4
.IX Item "dsn"
string value. dsn is connection information used by \s-1DBI\s0's \fIconnect()\fR method.
.IP "user" 4
.IX Item "user"
string value. user is database access user used by \s-1DBI\s0's \fIconnect()\fR method.
.IP "password" 4
.IX Item "password"
string value. user is database access password used by \s-1DBI\s0's \fIconnect()\fR method.
.IP "attrs" 4
.IX Item "attrs"
hash reference value. attrs is optional parameter used by \s-1DBI\s0's \fIconnect()\fR method.
.IP "opts" 4
.IX Item "opts"
hash reference value. opts is optional parameter used by this module.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Create DBIx::DBHResolver instance.
.ie n .SS "load( $yaml_file_path )"
.el .SS "load( \f(CW$yaml_file_path\fP )"
.IX Subsection "load( $yaml_file_path )"
Load config file formatted yaml.
.SS "config( \e%config )"
.IX Subsection "config( %config )"
Load config. Example config (perl hash reference format):
.PP
.Vb 10
\&  +{
\&    clusters => +{
\&      diary_master => [qw/diary001_master diary002_master/],
\&      people_master => [qw/people001_master people002_master people003_master people004_master/]
\&    },
\&    connect_info => +{
\&      diary001_master => +{
\&        dsn => \*(Aqdbi:driverName:...\*(Aq,
\&        user => \*(Aqroot\*(Aq, password => \*(Aq\*(Aq, attrs => +{},
\&      },
\&      diary002_master => +{ ... },
\&      ...
\&    },
\&  }
.Ve
.ie n .SS "connect( $cluster_or_node, $args )"
.el .SS "connect( \f(CW$cluster_or_node\fP, \f(CW$args\fP )"
.IX Subsection "connect( $cluster_or_node, $args )"
Retrieve database handle. If \f(CW$args\fR is scalar or array reference, then \f(CW$args\fR is treated sharding key.
If \f(CW$args\fR is hash reference, then see below.
.IP "strategy" 4
.IX Item "strategy"
Optional parameter. Specify suffix of strategy module name. Default strategy module is prefixed 'DBIx::DBHResolver::Strategy::'.
If you want to make custom strategy that is not started of 'DBIx::DBHResolver::Strategy::', then add prefix '+' at the beginning of the module name, such as '+MyApp::Strategy::Custom'.
.IP "key" 4
.IX Item "key"
Optional parameter. Strategy module uses hint choosing node.
.ie n .SS "connect_cached($cluster_or_node, $args)"
.el .SS "connect_cached($cluster_or_node, \f(CW$args\fP)"
.IX Subsection "connect_cached($cluster_or_node, $args)"
Retrieve database handle from own cache, if not exists cache then using \fIDBI::connect()\fR. \f(CW$args\fR is same as \fIconnect()\fR.
.ie n .SS "connect_info($cluster_or_node, $args)"
.el .SS "connect_info($cluster_or_node, \f(CW$args\fP)"
.IX Subsection "connect_info($cluster_or_node, $args)"
Retrieve connection info as \s-1HASHREF\s0. \f(CW$args\fR is same as \fIconnect()\fR.
.ie n .SS "resolve($cluster_or_node, $args)"
.el .SS "resolve($cluster_or_node, \f(CW$args\fP)"
.IX Subsection "resolve($cluster_or_node, $args)"
Return resolved node name. \f(CW$args\fR is same as connect.
.ie n .SS "resolve_node_keys($cluster_or_node, $keys, $args)"
.el .SS "resolve_node_keys($cluster_or_node, \f(CW$keys\fP, \f(CW$args\fP)"
.IX Subsection "resolve_node_keys($cluster_or_node, $keys, $args)"
Return hash resolved node and keys. \f(CW$args\fR is same as connect
.PP
.Vb 1
\&  use DBIx::DBHResolver;
\&
\&  my $resolver = DBIx::DBHResolver\->new;
\&  $resolver\->config(+{
\&    clusters => +{
\&      MASTER => +{
\&        nodes => [qw/MASTER001 MASTER002 MASTER003/],
\&        strategy => \*(AqKey\*(Aq,
\&      }
\&    },
\&    connect_info => +{
\&      MASTER001 => +{ ... },
\&      MASTER002 => +{ ... },
\&      MASTER003 => +{ ... },
\&    },
\&  });
\&
\&  my @keys = ( 3 .. 8 );
\&  my %node_keys = $resolver\->resolve_node_keys( \*(AqMASTER\*(Aq, \e@keys );
\&  ### %node_keys = ( MASTER001 => [ 3, 6 ], MASTER002 => [ 4, 7 ], MASTER003 => [ 5, 7 ] )
\&  while ( my ( $node, $keys ) = each %node_keys ) {
\&      process_node( $node, $keys );
\&  }
.Ve
.SS "\fIdisconnect_all()\fP"
.IX Subsection "disconnect_all()"
Disconnect all cached database handles.
.SS "cluster_info($cluster)"
.IX Subsection "cluster_info($cluster)"
Return cluster info hash ref.
.SS "clusters($cluster)"
.IX Subsection "clusters($cluster)"
Retrieve cluster member node names as Array.
.PP
.Vb 11
\&  my $r = DBIx::DBHResolver\->new;
\&  $r\->config(+{ ... });
\&  my $cluster_or_node = \*(Aqactivities_master\*(Aq;
\&  if ( $r\->is_cluster($cluster_or_node) ) {
\&    for ($r\->cluster( $cluster_or_node )) {
\&      process_activities_node($_);
\&    }
\&  }
\&  else {
\&    process_activities_node($cluster_or_node);
\&  }
.Ve
.SS "is_cluster($cluster)"
.IX Subsection "is_cluster($cluster)"
Return boolean value which cluster or not given name.
.SS "is_node($node)"
.IX Subsection "is_node($node)"
Return boolean value which node or not given name.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .SS "$CONFIG"
.el .SS "\f(CW$CONFIG\fP"
.IX Subsection "$CONFIG"
Stored config on using class module.
.ie n .SS "$DBI"
.el .SS "\f(CW$DBI\fP"
.IX Subsection "$DBI"
\&\s-1DBI\s0 module name, default '\s-1DBI\s0'. If you want to use custom \s-1DBI\s0 sub class, then you must override this variable.
.ie n .SS "$DBI_CONNECT_METHOD"
.el .SS "\f(CW$DBI_CONNECT_METHOD\fP"
.IX Subsection "$DBI_CONNECT_METHOD"
\&\s-1DBI\s0 connect method name, default 'connect';
.PP
If you want to use DBIx::Connector instead of \s-1DBI\s0, then:
.PP
.Vb 2
\&  use DBIx::Connector;
\&  use DBIx::DBHResolver;
\&
\&  $DBIx::DBHResolver::DBI = \*(AqDBIx::Connector\*(Aq;
\&  $DBIx::DBHResolver::DBI_CONNECT_METHOD = \*(Aqnew\*(Aq;
\&  $DBIx::DBHResolver::DBI_CONNECT_CACHED_METHOD = \*(Aqnew\*(Aq;
\&
\&  my $r = DBIx::DBHResolver\->new;
\&  $r\->config(+{...});
\&
\&  $r\->connect(\*(Aqmain_master\*(Aq)\->txn(
\&    fixup => sub {
\&      my $dbh = shift;
\&      ...
\&    }
\&  );
.Ve
.ie n .SS "$DBI_CONNECT_CACHED_METHOD"
.el .SS "\f(CW$DBI_CONNECT_CACHED_METHOD\fP"
.IX Subsection "$DBI_CONNECT_CACHED_METHOD"
\&\s-1DBI\s0 connect method name, default 'connect_cached';
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Kosuke Arisawa <arisawa@gmail.com>" 4
.IX Item "Kosuke Arisawa <arisawa@gmail.com>"
.PD 0
.IP "Toru Yamaguchi <zigorou@cpan.org>" 4
.IX Item "Toru Yamaguchi <zigorou@cpan.org>"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\s-1DBI\s0" 4
.IX Item "DBI"
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
