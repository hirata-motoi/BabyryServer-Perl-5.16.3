.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Imager::API 3"
.TH Imager::API 3 "2013-09-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::API \- Imager's C API \- introduction.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  #include "imext.h"
\&  #include "imperl.h"
\&
\&  DEFINE_IMAGER_CALLBACKS;
\&
\&  MODULE = Your::Module  PACKAGE = Your::Module
\&
\&  ...
\&
\&  BOOT:
\&    /* any release with the API */
\&    PERL_INITIALIZE_IMAGER_CALLBACKS;
\&    /* preferred from Imager 0.91 */
\&    PERL_INITIALIZE_IMAGER_CALLBACKS_NAME("My::Module");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1API\s0 allows you to access Imager functions at the C level from \s-1XS\s0
and from \f(CW\*(C`Inline::C\*(C'\fR.
.PP
The intent is to allow users to:
.IP "\(bu" 4
write C code that does Imager operations the user might do from Perl,
but faster, for example, the Imager::CountColor example.
.IP "\(bu" 4
write C code that implements an application specific version of some
core Imager object, for example, Imager::SDL.
.IP "\(bu" 4
write C code that hooks into Imager's existing methods, such as filter
or file format handlers.
.PP
See Imager::Inline for information on using Imager's Inline::C
support.
.SH "Beware"
.IX Header "Beware"
.IP "\(bu" 4
don't return an object you received as a parameter \- this will cause
the object to be freed twice.
.SH "Types"
.IX Header "Types"
The \s-1API\s0 makes the following types visible:
.IP "\(bu" 4
\&\*(L"i_img\*(R" \- used to represent an image
.IP "\(bu" 4
\&\*(L"i_color\*(R" \- used to represent a color with up
to 8 bits per sample.
.IP "\(bu" 4
\&\*(L"i_fcolor\*(R" \- used to represent
a color with a double per sample.
.IP "\(bu" 4
\&\*(L"i_fill_t\*(R" \- fill objects>> \- an abstract fill
.IP "\(bu" 4
\&\*(L"im_context_t\*(R" \- Imager's per-thread state.
.PP
At this point there is no consolidated font object type, and hence the
font functions are not visible through Imager's \s-1API\s0.
.SS "i_img"
.IX Subsection "i_img"
This contains the dimensions of the image (\f(CW\*(C`xsize\*(C'\fR, \f(CW\*(C`ysize\*(C'\fR,
\&\f(CW\*(C`channels\*(C'\fR), image metadata (\f(CW\*(C`ch_mask\*(C'\fR, \f(CW\*(C`bits\*(C'\fR, \f(CW\*(C`type\*(C'\fR,
\&\f(CW\*(C`virtual\*(C'\fR), potentially image data (\f(CW\*(C`idata\*(C'\fR) and a function table,
with pointers to functions to perform various low level image
operations.
.PP
The only time you should directly write to any value in this type is
if you're implementing your own image type.
.PP
The typemap includes type names Imager and Imager::ImgRaw as typedefs
for \f(CW\*(C`i_img *\*(C'\fR.
.PP
For incoming parameters the typemap will accept either Imager or
Imager::ImgRaw objects.
.PP
For return values the typemap will produce a full Imager object for an
Imager return type and a raw image object for an Imager::ImgRaw return
type.
.SS "i_color"
.IX Subsection "i_color"
Represents an 8\-bit per sample color.  This is a union containing
several different structs for access to components of a color:
.IP "\(bu" 4
\&\f(CW\*(C`gray\*(C'\fR \- single member \f(CW\*(C`gray_color\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`rgb\*(C'\fR \- \f(CW\*(C`r\*(C'\fR, \f(CW\*(C`g\*(C'\fR, \f(CW\*(C`b\*(C'\fR members.
.IP "\(bu" 4
\&\f(CW\*(C`rgba\*(C'\fR \- \f(CW\*(C`r\*(C'\fR, \f(CW\*(C`g\*(C'\fR, \f(CW\*(C`b\*(C'\fR, \f(CW\*(C`a\*(C'\fR members.
.IP "\(bu" 4
\&\f(CW\*(C`channels\*(C'\fR \- array of channels.
.PP
Use \f(CW\*(C`Imager::Color\*(C'\fR for parameter and return value types.
.SS "i_fcolor"
.IX Subsection "i_fcolor"
Similar to \f(CW\*(C`i_color\*(C'\fR except that each component is a double instead of
an unsigned char.
.PP
Use Imager::Color::Float for parameter and return value types.
.SS "i_fill_t"
.IX Subsection "i_fill_t"
Abstract type containing pointers called to perform low level fill
operations.
.PP
Unless you're defining your own fill objects you should treat this as
an opaque type.
.PP
Use Imager::FillHandle for parameter and return value types.  At the
Perl level this is stored in the \f(CW\*(C`fill\*(C'\fR member of the Perl level
Imager::Fill object.
.SS "i_io_glue_t"
.IX Subsection "i_io_glue_t"
\&\f(CW\*(C`i_io_glue_t\*(C'\fR is Imager's I/O abstraction.
.PP
Historically named \f(CW\*(C`io_glue\*(C'\fR, and this name is available for backward
compatibility.
.SS "im_context_t"
.IX Subsection "im_context_t"
This new type is an opaque type that stores Imager's per-thread state,
including the error message stack, the current log file state and
image size file limits.
.PP
While Imager's internal typemap provides a \f(CW\*(C`T_PTROBJ\*(C'\fR mapping and a
\&\s-1DESTROY\s0 method for this type you \fBmust\fR never return objects of this
type back to perl.
.PP
See \*(L"Context objects\*(R" for more information.
.SH "Create an XS module using the Imager API"
.IX Header "Create an XS module using the Imager API"
.SS "Foo.pm"
.IX Subsection "Foo.pm"
Load Imager:
.PP
.Vb 1
\&  use Imager 0.48;
.Ve
.PP
and bootstrap your \s-1XS\s0 code \- see XSLoader or DynaLoader.
.ie n .SS """Foo.xs"""
.el .SS "\f(CWFoo.xs\fP"
.IX Subsection "Foo.xs"
You'll need the following in your \s-1XS\s0 source:
.IP "\(bu" 4
include the Imager external \s-1API\s0 header, and the perl interface header:
.Sp
.Vb 2
\&  #include "imext.h"
\&  #include "imperl.h"
.Ve
.IP "\(bu" 4
create the variables used to hold the callback table:
.Sp
.Vb 1
\&  DEFINE_IMAGER_CALLBACKS;
.Ve
.IP "\(bu" 4
initialize the callback table in your \f(CW\*(C`BOOT\*(C'\fR code:
.Sp
.Vb 2
\&  BOOT:
\&    PERL_INITIALIZE_IMAGER_CALLBACKS;
.Ve
.Sp
From Imager 0.91 you can supply your module name to improve error
reporting:
.Sp
.Vb 2
\&  BOOT:
\&    PERL_INITIALIZE_IMAGER_CALLBACKS_NAME("My::Module");
.Ve
.SS "foo.c"
.IX Subsection "foo.c"
In any other source files where you want to access the Imager \s-1API\s0,
you'll need to:
.IP "\(bu" 4
include the Imager external \s-1API\s0 header:
.Sp
.Vb 1
\&  #include "imext.h"
.Ve
.ie n .SS """Makefile.PL"""
.el .SS "\f(CWMakefile.PL\fP"
.IX Subsection "Makefile.PL"
If you're creating an \s-1XS\s0 module that depends on Imager's \s-1API\s0 your
\&\f(CW\*(C`Makefile.PL\*(C'\fR will need to do the following:
.IP "\(bu" 4
\&\f(CW\*(C`use Imager::ExtUtils;\*(C'\fR
.IP "\(bu" 4
include Imager's include directory in \s-1INC:\s0
.Sp
.Vb 1
\&  INC => Imager::ExtUtils\->includes
.Ve
.IP "\(bu" 4
use Imager's typemap:
.Sp
.Vb 1
\&  TYPEMAPS => [ Imager::ExtUtils\->typemap ]
.Ve
.IP "\(bu" 4
include Imager 0.48 as a \s-1PREREQ_PM:\s0
.Sp
.Vb 4
\&   PREREQ_PM =>
\&   {
\&    Imager => 0.48,
\&   },
.Ve
.IP "\(bu" 4
Since you use Imager::ExtUtils in \f(CW\*(C`Makefile.PL\*(C'\fR (or \f(CW\*(C`Build.PL\*(C'\fR) you
should include Imager in your configure_requires:
.Sp
.Vb 4
\&   META_MERGE =>
\&   {
\&     configure_requires => { Imager => "0.48" }
\&   },
.Ve
.SH "Context objects"
.IX Header "Context objects"
Starting with Imager 0.93, Imager keeps some state per-thread rather
than storing it in global (or static) variables.  The intent is to
improve support for multi-threaded perl programs.
.PP
For the typical \s-1XS\s0 or Inline::C module using Imager's \s-1API\s0 this won't
matter \- the changes are hidden behind macros and rebuilding your
module should require no source code changes.
.PP
Some operations will be slightly slower, these include:
.IP "\(bu" 4
creating an image
.IP "\(bu" 4
reporting errors
.IP "\(bu" 4
creating I/O objects
.IP "\(bu" 4
setting/getting/testing image file limits
.IP "\(bu" 4
logging
.PP
You can avoid this fairly minor overhead by adding a \f(CW\*(C`#define\*(C'\fR:
.PP
.Vb 1
\&  #define IMAGER_NO_CONTEXT
.Ve
.PP
before including any Imager header files, but you will need to manage
context objects yourself.
.PP
Some functions and macros that are available without
\&\f(CW\*(C`IMAGER_NO_CONTEXT\*(C'\fR are not available with it defined, these are:
.IP "\(bu" 4
\&\fImm_log()\fR \- to avoid using a different context object for the line
header and the line text you need to use \fIim_log()\fR instead, with a
context object visible in scope.
.ie n .SS """aIMCTX"""
.el .SS "\f(CWaIMCTX\fP"
.IX Subsection "aIMCTX"
With \f(CW\*(C`IMAGER_NO_CONTEXT\*(C'\fR defined, \f(CW\*(C`aIMCTX\*(C'\fR refers to the locally
defined context object, either via one the of the \f(CW\*(C`dIMCTX\*(C'\fR macros or
as a parameter with the \f(CW\*(C`pIMCTX\*(C'\fR macro.
.PP
Without \f(CW\*(C`IMAGER_NO_CONTEXT\*(C'\fR, \f(CW\*(C`aIMCTX\*(C'\fR is a call to
\&\f(CW\*(C`im_get_context()\*(C'\fR which retrieves the context object for the current
thread.
.PP
There is no \f(CW\*(C`aIMCTX_\*(C'\fR macro, any Imager function that can accept a
context parameter always accepts it.
.ie n .SS """pIMCTX"""
.el .SS "\f(CWpIMCTX\fP"
.IX Subsection "pIMCTX"
This macro declares a variable of type \*(L"im_context_t\*(R" that's
accessible via the \f(CW\*(C`aIMCTX\*(C'\fR macro.  This is intended for use as a
parameter declaration for functions:
.PP
.Vb 3
\&  void f(pIMCTX) {
\&    ... use aIMCTX here
\&  }
\&
\&  void g(...) {
\&    ...
\&    f(aIMCTX);
\&  }
.Ve
.ie n .SS """dIMCTX"""
.el .SS "\f(CWdIMCTX\fP"
.IX Subsection "dIMCTX"
Defines a local context variable and initializes it via
\&\fIim_get_context()\fR.
.ie n .SS """dIMCTXim"""
.el .SS "\f(CWdIMCTXim\fP"
.IX Subsection "dIMCTXim"
Defines a local context variable and initializes it from the context
stored in an image object, eg:
.PP
.Vb 4
\&  void f(i_img *im) {
\&    dIMCTXim(im);
\&    ...
\&  }
.Ve
.ie n .SS """dIMCTXio"""
.el .SS "\f(CWdIMCTXio\fP"
.IX Subsection "dIMCTXio"
Defines a local context variable and initializes it from the context
stored in an I/O object object.
.PP
.Vb 4
\&  void f(i_io_glue_t *io) {
\&    dIMCTXio(io);
\&    ...
\&  }
.Ve
.ie n .SS """dIMCTXctx"""
.el .SS "\f(CWdIMCTXctx\fP"
.IX Subsection "dIMCTXctx"
Defines a local context variable accessible via \f(CW\*(C`aIMCTX\*(C'\fR in terms of
an expression you supply:
.PP
.Vb 4
\&  void f(my_object *p) {
\&    dIMCTXctx(p\->context);
\&    ...
\&  }
.Ve
.PP
This can be used to define your own local context macro:
.PP
.Vb 1
\&  #define dIMCTXmine(mine) ((mine)\->context)
\&
\&  void f(my_object *p) {
\&    dIMCTXmine(p);
\&    ...
\&  }
.Ve
.SH "Mutex Functions"
.IX Header "Mutex Functions"
Since some libraries are not thread safe, Imager's \s-1API\s0 includes some
simple mutex functions.
.PP
To create a mutex:
.PP
.Vb 1
\&  i_mutex_t m = i_mutex_new();
.Ve
.PP
To control or lock the mutex:
.PP
.Vb 1
\&  i_mutex_lock(m);
.Ve
.PP
To release or unlock the mutex:
.PP
.Vb 1
\&  i_mutex_unlock(m);
.Ve
.PP
To free any resources used by the mutex:
.PP
.Vb 1
\&  i_mutex_destroy(m);
.Ve
.PP
I most cases where you'd use these functions, your code would create
the mutex in your \s-1BOOT\s0 section, then lock and unlock the mutex as
needed to control access to the library.
.SH "Context slots"
.IX Header "Context slots"
To avoid abstracting the platform \s-1TLS\s0 and thread clean up handling,
Imager provides simple APIs for storing per-context information.
.PP
To allocate a slot:
.PP
.Vb 1
\&  im_slot_t slot = im_context_slot_new(callback)
.Ve
.PP
where callback is a (possibly \s-1NULL\s0) function pointer called when the
context object is destroyed.
.PP
By default, the stored value for a slot is \s-1NULL\s0, whether for a new
context or for a cloned context.
.PP
To store a value:
.PP
.Vb 1
\&  im_context_slot_set(aIMCTX, slot, somevalue);
.Ve
.PP
where \f(CW\*(C`somevalue\*(C'\fR can be represented as a \f(CW\*(C`void *\*(C'\fR.
.PP
To retrieve the value:
.PP
.Vb 1
\&  value = im_context_slot_get(aIMCTX, slot);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Tony Cook <tonyc@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Imager, Imager::ExtUtils, Imager::APIRef, Imager::Inline
